---
title: "Presentation"
author: "Jungwoo Lee, Andy Lu, Jay Shi, Erica Zhong"
date: "November 29, 2018"
output:
  beamer_presentation: default
  ioslides_presentation: default
  slidy_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(error = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

```{r, error=FALSE, warning=FALSE}
library(jsonlite)
library(ggplot2)
library(knitr)
library(RSQLite)
library(stringr)
library(dplyr)
library(ggplot2)
library(RSelenium)
library(magrittr)
library(janeaustenr)
library(tidytext)
library(jsonlite)
library(dbplyr)
library(ggplot2)
library(knitr)
library(RSQLite)
library(stringr)
library(dplyr)
library(wordcloud)
library(RColorBrewer)
library(grid)
library(gridBase)
library(tm)
library(RSQLite)

cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
"#F0E442", "#0072B2", "#D55E00", "#CC79A7","#6b3447")
theme1 <- theme_bw() +
theme(axis.text = element_text(size = 8, colour = "#6b3447"),
axis.title = element_text(size = 10, colour = "#2f2f63"),
legend.title = element_text(size = 8, colour = "#2f2f63"),
legend.text = element_text(size = 8, colour = "#6b3447"),
title = element_text(size = 12, colour = "#2f2f63"),
axis.ticks = element_line(colour = "#6b3447"),
plot.caption = element_text(size = 8, colour = "#2f2f63"),
plot.subtitle = element_text(size = 10, colour = "#2f2f63"))

```

```{r}
businesses <- read.csv("yelp_academic_dataset_business.csv", header = TRUE)
head(businesses)
nrow(businesses)
ncol(businesses)
att <- head(businesses$attributes)
```

## Key Aspects

- Overview of Dataset
- Introductory plots
- Difference between restaurants and non-restaurants
- Yelp vs. TripAdvisor 
- kNN Model on Attributes

## Overview of Dataset
- yelp_academic_dataset_business
- 188592 rows
- 16 columns

## Central Question
How can we predict Yelp business star ratings based on business attributes?
Is there a way to gain higher ratings through intentional inclusion of attributes?

## Distribution of Ratings s

```{r}
ggplot(businesses, aes(x = stars)) + geom_bar(stat = "count", fill = "chocolate") + 
  ggtitle("Distribution of Aggregate Ratings of Businesses") +
  xlab("Ratings") +
  ylab("Frequency")
```


## Distribution of Businesses Across States
```{r}
top10States <- sort(table(businesses$state), decreasing = TRUE)[1:10]
otherStates <- dim(businesses)[1] - sum(top10States)
top10States['Others'] <- otherStates
barplot(as.vector(top10States), names.arg = attr(top10States, "names"), main = "Number of Businesses Per State/Province", xlab = "State/Province", ylab = "Count", col = cbPalette)
```


## Distribution of Review Counts

```{r}
grid.newpage()
a <- ggplot(businesses) + aes(x = review_count) + geom_bar(fill = "salmon") + 
  ggtitle("Distribution of Review Counts") + 
  xlim(0,100) +
  xlab("Review Counts") + 
  ylab("Frequency")

b <- ggplot(businesses, aes(x=review_count, y=stars)) + geom_point(size = 0.3, alpha = 0.1) + ggtitle("Ratings vs. Review Counts") + 
  xlim(0,300) +
  xlab("Number of Reviews") + 
  ylab("Star Rating")
vpa <- viewport(x = 0.5, y = 0.5, width = 1, height = 1)
vpb <- viewport(x = 0.70, y = 0.6, width = 0.6, height = 0.6)
print(a, vp = vpa)
print(b, vp = vpb)

```

## Average Rating Across Categories

```{r}
BusiData <- as.data.frame(businesses)
Categories = c("Food", "Barbers", "Home Services", "Health", "Shopping", "Restaurants", "Nightlife", "Bars")
Ave_Review = c()

for (index in 1:length(Categories)){
  Category <- filter(BusiData, str_detect(`categories`, Categories[index]))
  CategoryAverage <- sum(Category$stars)/nrow(Category)
  Ave_Review[index] <- CategoryAverage
}

ggplot(data.frame(Categories), aes(x = Categories, y = Ave_Review, fill = Categories) )+ geom_bar(stat="identity") +  ggtitle("Average Rating Across Categories") +xlab("Categories") + ylab("Average Rating") + theme(axis.text.x = element_text(angle = 35, hjust=1))

```

## Comparison Between Restaurants and Non-Restaurants
```{r}
total <- select(businesses, categories, stars)
restaurantsOnly <- filter(total, str_detect(categories, 'Restaurants'))
notRestaurants <- setdiff(total, restaurantsOnly)

rest <- ggplot(notRestaurants) + aes(x = stars) + geom_bar(fill = "#ABCDEF") +
  ggtitle("Distribution of Aggregate Ratings of Non-restaurants") +
  xlab("Ratings") +
  ylab("Frequency")

nonrest <- ggplot(restaurantsOnly) + aes(x = stars) + geom_bar(fill = "#FF6666") +
  ggtitle("Distribution of Aggregate Ratings of Restaurants") +
  xlab("Ratings") +
  ylab("Frequency")
grid.newpage()
vpr <- viewport(x = 0.5, y = 0.75, width = 1, height = 0.5)
vpnr <- viewport(x = 0.5, y = 0.25, width = 1, height = 0.5)
print(rest, vp = vpr)
print(nonrest, vp = vpnr)
```

## Average Rating Across States
```{r}
stateStars <- select(
  mutate(businesses,
         new_state = ifelse(state %in% attr(top10States, "names"),
                            as.character(state),
                            "Others")),
  new_state, stars
  )

avg_stars <- summarise(
  group_by(stateStars, new_state),
  avg_star = mean(stars)
  )

avg_stars$new_state <- factor(avg_stars$new_state,c("AB","AZ","IL","NC","NV","OH","ON","PA","QC","WI","Others"))

ggplot(avg_stars) +
  aes(x = new_state, y = avg_star, fill = new_state) +
  geom_bar(stat = "identity") +
  ggtitle("Average Ratings across States/Provinces") +
  xlab("State/Province") +
  ylab("Average Ratings")
```

## Yelp vs. TripAdvisor
Two Word Clouds

## Model
- kNN Model
- 20 attributes used to predict star rating of a restaurant
- Trained data on 80% of data, tested on 20%
- k = 5 neighbors
# In simple terms, the k nearest neighbours algorithm is an algorithm that works based on a similarity concept. That is, for any new data point to be predicted based on an existing data set, if the majority of “k” neighbours of the new point belong to a particular class, then the new point also belongs to that class.

## Predicting Using All Attributes
- Accuracy = 57.58%.


## Predicting Using Individual Attributes


##Killer Plot
```{r}
library(grid)
library(gridBase)
grid.newpage()
text_color = "white"

vp.1 <- viewport(x = 0, y = 0.5, w = 0.5, h = 0.5,
                just = c("left", "bottom"))

pushViewport(vp.1)

Negative_Attributes1 = c("no parking","","never","time","","people", "","","","staff","back","dislike","terrible","","")

s_x =c(0.9,0.91,0.9,0.91,0.85,0.83,0.81,0.79,0.78,0.77,0.69,0.64,0.6,0.62,0.61)
s_y = c(0.8,0.75,0.7,0.65,0.7,0.69,0.68,0.55,0.5,0.45,0.43,0.42,0.46,0.48,0.53)
grid.rect(gp = gpar(fill = "black"))

for (i in 1:length(Negative_Attributes1)) {
  if (Negative_Attributes1[i] != ""){
    grid.circle(x = s_x[i], y = s_y[i], r = 0.01,gp=gpar(fill = "yellow"))
  }
  
  grid.text(Negative_Attributes1[i], x = s_x[i], y = s_y[i] + 0.02,gp = gpar(fontsize = 8, fontface = "bold",col = text_color))
}

#Scorpio (negative)
grid.lines(x = c(0.9,0.91,0.9,0.91), y = c(0.8,0.75,0.7,0.65), gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))
grid.lines(x = c(0.91,0.85,0.83,0.81,0.79,0.78,0.77,0.69,0.64,0.6,0.62,0.61), y = c(0.75,0.7,0.69,0.68,0.55,0.5,0.45,0.43,0.42,0.46,0.48,0.53), gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))

Negative_Attributes2 = c("","","poor","","food","","service","","","","Accepts Credit Card","","","","")
#Cetus (negative)

c_x = c(0.5,0.45,0.4,0.42,0.47,0.45,0.52,0.59,0.62,0.55,0.65,0.69,0.75,0.81)
c_y = c(0.4,0.45,0.4,0.35,0.36,0.3,0.27,0.26,0.18,0.12,0.26,0.23,0.12,0.24)

for (i in 1:length(Negative_Attributes2)) {
  if (Negative_Attributes2[i] != ""){
    grid.circle(x = c_x[i], y = c_y[i], r = 0.01,gp=gpar(fill = "yellow"))
  }
  grid.text(Negative_Attributes2[i], x = c_x[i], y = c_y[i] + 0.02, gp = gpar(fontsize = 8, fontface = "bold", col = text_color))
}

grid.lines(x = c(0.5,0.45,0.4,0.42,0.47,0.5), y = c(0.4,0.45,0.4,0.35,0.36,0.4), gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))

grid.lines(x = c(0.42, 0.45,0.52,0.59,0.62,0.55),y = c(0.35,0.3,0.27,0.26,0.18,0.12), gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))

grid.lines(x= c(0.59,0.65,0.69,0.75,0.81,0.69), y = c(0.26,0.26,0.23,0.12,0.24,0.23),gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))


Positive_Attributes1 = c("service","validated parking","","No credit Card","","","friendly","","", "staff","")

#Perseus (positive)

per_x = c(0.1,0.04,0.03,0.02,0.01,0.01,0.03,0.04,0.1,0.14,0.18) + 0.07
per_y = c(0.8,0.75,0.65,0.55,0.45,0.3,0.2,0.24,0.55,0.45,0.48)

for (i in 1:length(Positive_Attributes1)) {
  if (Positive_Attributes1[i] != ""){
    grid.circle(x = per_x[i], y = per_y[i], r = 0.01,gp=gpar(fill = "yellow"))
  }
  grid.text(Positive_Attributes1[i], x = per_x[i], y = per_y[i] + 0.02,gp = gpar(fontsize = 8, fontface = "bold",col = text_color))
}

grid.lines(x= c(0.1,0.04,0.03,0.02,0.01,0.01,0.03,0.04) + 0.07,y=c(0.8,0.75,0.65,0.55,0.45,0.3,0.2,0.24),gp = gpar(col = rgb(1,1,0,0.5),lwd = 2))

grid.lines(x = c(0.02,0.1,0.14,0.18) + 0.07, y = c(0.55,0.55,0.45,0.48),gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))

#Hercule(positive)
Positive_Attributes2 = c("love","amazing","","valet","","street parking","","","","garage","","","")
h_x = c(0.43,0.38,0.35,0.38,0.40,0.32,0.32,0.31,0.25,0.26,0.27,0.23,0.20)
h_y = c(0.9,0.83,0.76,0.68,0.60,0.50,0.63,0.73,0.74,0.88,0.55,0.62,0.62)

for (i in 1:length(Positive_Attributes2)) {
  if (Positive_Attributes2[i] != ""){
    grid.circle(x = h_x[i], y = h_y[i], r = 0.01,gp=gpar(fill = "yellow"))
  }
  grid.text(Positive_Attributes2[i], x = h_x[i], y = h_y[i] + 0.02,gp = gpar(fontsize = 8, fontface = "bold",col = text_color))
}

grid.lines(x = c(0.43,0.38,0.35,0.38,0.40,0.32), y = c(0.9,0.83,0.76,0.68,0.60,0.50), gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))

grid.lines(x = c(0.26,0.25,0.31,0.32,0.27,0.23,0.20), y = c(0.88,0.74,0.73,0.63,0.55,0.62,0.62), gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))

grid.lines(x = c(0.31,0.35), y = c(0.73,0.76), gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))

grid.lines(x = c(0.32,0.38), y = c(0.63,0.68),gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))

Neutral_Attributes1 = c("HasTV","child-friendly","","reservation","","latenight")

#Lyra (neutral)
l_x = c(0.76,0.8,0.73,0.64,0.58,0.66)
l_y = c(0.9,0.83,0.8,0.8,0.7,0.7)

for (i in 1:length(Neutral_Attributes1)) {
  if (Neutral_Attributes1[i] != ""){
    grid.circle(x = l_x[i], y = l_y[i], r = 0.01,gp=gpar(fill = "yellow"))
  }
  grid.text(Neutral_Attributes1[i], x = l_x[i], y = l_y[i] + 0.02, gp = gpar(fontsize = 8, fontface = "bold",col = text_color))
}

grid.lines(x = c(0.76,0.8,0.73,0.76),y = c(0.9,0.83,0.8,0.9),gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))
grid.lines(x = c(0.64,0.58,0.66,0.73,0.64), y = c(0.8,0.7,0.7,0.8,0.8), gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))


#Microscopium (neutral)
Neutral_Attributes2 = c("","staff", "", "Wheelchair Accessible", "","Outdoor Seating")
m_x = c(0.24,0.3,0.35,0.35,0.24)
m_y = c(0.3,0.3,0.25,0.1,0.15)

for (i in 1:length(Neutral_Attributes2)){
  if (Neutral_Attributes2[i] != ""){
    grid.circle(x = m_x[i], y = m_y[i], r = 0.01, gp=gpar(fill = "yellow"))
  }
  grid.text(Neutral_Attributes2[i],x=m_x[i], y=m_y[i] + 0.02 ,gp = gpar(fontsize = 8, fontface = "bold",col = text_color))
}

grid.lines(x = c(0.24,0.3,0.35,0.35,0.24,0.24), y = c(0.3,0.3,0.25,0.1,0.15,0.3), gp = gpar(col = rgb(1,1,0,0.5), lwd = 2))


grid.text("Constellation of Attributes", y = unit(20.5,"lines"), gp=gpar(fontsize=10, col="white", fontface = "italic"))


popViewport()
```









## Conclusion

